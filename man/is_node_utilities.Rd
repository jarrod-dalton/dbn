% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/is_node_utilities.R
\name{is_node_utilities}
\alias{is_node}
\alias{is_node_decision}
\alias{is_node_deterministic}
\alias{is_node_dynamic}
\alias{is_node_parent}
\alias{is_node_parent_of}
\alias{is_node_utilities}
\alias{is_node_utility}
\title{Utilities to identify node attributes}
\usage{
is_node(network, node = NULL)

is_node_parent(network, node = NULL)

is_node_parent_of(network, node = NULL, child)

is_node_decision(network, node = NULL)

is_node_deterministic(network, node = NULL)

is_node_dynamic(network, node = NULL)

is_node_utility(network, node = NULL)
}
\arguments{
\item{network}{An object of class \code{dbn}.}

\item{node}{A character vector of nodes for which the formula definitions 
are to be obtained. If \code{NULL}, a logical for each node is returned.}

\item{child}{A \code{character(1)} vector used in \code{is_node_parent_of}. 
This is the node for which \code{node} are being tested as parents.}
}
\description{
Methods to quickly get logical indications of the attributes
  of a node.  These may all be done through subsetting the 
  \code{node_attr} attribute of the network object.  These functions
  perform the work in a standardized way, allowing less typing.
}
\details{
\code{is_node_parent} returns a logical stating if the node is a parent of
  at least one other node.
  
\code{is_node_parent_of} returns a logical stating if node is a parent of 
  at least one element of \code{child}
  
\code{is_node_dynamic} Is the node a dynamic node. \code{get_node_dynamic}
is an alias.
  
\code{is_node_decision} Is the node a decision node. \code{get_node_decision}
is an alias.

\code{is_node_utility} Is the node a utility node. \code{get_node_utility}
is an alias.

\code{is_node_deterministic} Is the node a deterministic node.  
\code{get_node_deterministic} is an alias.

\code{is_node_something} is an unexported generalized form from which 
\code{is_node_dynamic}, \code{is_node_decision}, \code{is_node_utility},
\code{is_node_deterministic} are derived.  This is done to minimize the
code base that needs to be maintained.
}
\section{Functional Requirements}{

\emph{is_node}

\enumerate{
 \item Return a named logical vector the length of \code{node} indicating
   if each element in node is a valid node name in \code{network}.
 \item Cast an error if \code{network} is not a \code{dbn} object.
 \item Cast an error if \code{node} is not a character vector.
}

\emph{is_node_parent}

\enumerate{
 \item Return a named logical vector the length of \code{node} indicating
   if each element is a parent of another node in \code{network}
 \item If \code{node = NULL}, \code{node} is assumed to be the 
    vector of all node names.
  \item If any \code{node} is not a node in \code{network}, cast a warning
      and drop the invalid nodes.
  \item If \code{network} is not a \code{dbn}, cast an error.
}

\emph{is_node_parent_of}

\enumerate{
 \item Return a named logical vector the length of \code{node} indicating
   if each element is a parent of another node in \code{network}
 \item If \code{node = NULL}, \code{node} is assumed to be the 
    vector of all node names.
  \item If any \code{node} is not a node in \code{network}, cast a warning
      and drop the invalid nodes.
  \item If \code{network} is not a \code{dbn}, cast an error.
  \item Cast an error if \code{child} is not a \code{character(1)}
  \item Cast an error if \code{child} is not a node in \code{network}
}

\emph{is_node_dynamic, is_node_decision, is_utility, is_deterministic}

\enumerate{
  \item Each method returns a logical vector (except for \code{get_node_parent}).
  \item If \code{node = NULL}, \code{node} is assumed to be the 
    vector of all node names.
  \item If any \code{node} is not a node in \code{network}, cast a warning
      and drop the invalid nodes.
  \item If \code{network} is not a \code{dbn}, cast an error.
}
}
\seealso{
\code{\link{set_node_utilities}} \code{\link{get_node_utilities}}
}

